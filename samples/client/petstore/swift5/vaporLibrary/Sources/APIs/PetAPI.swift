//
// PetAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

open class PetAPI {

    public enum AddPet {
        case http405(value: Void?, raw: ClientResponse)
        case http0(value: Void?, raw: ClientResponse)
    }

    /**
     Add a new pet to the store

     POST /pet

     - OAuth:
       - type: oauth2
       - name: petstore_auth
     - parameter body: (body) Pet object that needs to be added to the store 
     - returns: `EventLoopFuture` of `AddPet` 
     */
    open class func addPet(body: Pet, headers: HTTPHeaders = PetstoreClient.customHeaders, beforeSend: (inout ClientRequest) throws -> () = { _ in }) -> EventLoopFuture<AddPet> {
        let path = "/pet"
        let URLString = PetstoreClient.basePath + path

        guard let apiClient = Configuration.apiClient else {
            fatalError("Configuration.apiClient is not set.")
        }

        return apiClient.send(.POST, headers: headers, to: URI(string: URLString)) { request in
            try Configuration.apiWrapper(&request)
            
            
            try request.content.encode(body, using: Configuration.contentConfiguration.requireEncoder(for: Pet.defaultContentType))
            
            try beforeSend(&request)
        }.flatMapThrowing { response -> AddPet in
            switch response.status.code {
            case 405:
                return .http405(value: (), raw: response)
            default:
                return .http0(value: (), raw: response)
            }
        }
    }



    public enum DeletePet {
        case http400(value: Void?, raw: ClientResponse)
        case http0(value: Void?, raw: ClientResponse)
    }

    /**
     Deletes a pet

     DELETE /pet/{petId}

     - OAuth:
       - type: oauth2
       - name: petstore_auth
     - parameter petId: (path) Pet id to delete 
     - parameter apiKey: (header)  (optional)
     - returns: `EventLoopFuture` of `DeletePet` 
     */
    open class func deletePet(petId: Int64, apiKey: String? = nil, headers: HTTPHeaders = PetstoreClient.customHeaders, beforeSend: (inout ClientRequest) throws -> () = { _ in }) -> EventLoopFuture<DeletePet> {
        var path = "/pet/{petId}"
        let petIdPreEscape = String(describing: petId)
        let petIdPostEscape = petIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{petId}", with: petIdPostEscape, options: .literal, range: nil)
        let URLString = PetstoreClient.basePath + path

        guard let apiClient = Configuration.apiClient else {
            fatalError("Configuration.apiClient is not set.")
        }

        return apiClient.send(.DELETE, headers: headers, to: URI(string: URLString)) { request in
            try Configuration.apiWrapper(&request)
            
            request.headers.add(name: "api_key", value: apiKey?.description ?? "")
            
            
            
            try beforeSend(&request)
        }.flatMapThrowing { response -> DeletePet in
            switch response.status.code {
            case 400:
                return .http400(value: (), raw: response)
            default:
                return .http0(value: (), raw: response)
            }
        }
    }



    /**
     * enum for parameter status
     */
    public enum Status_findPetsByStatus: String, CaseIterable, Content {
        case available = "available"
        case pending = "pending"
        case sold = "sold"
    }

    public enum FindPetsByStatus {
        case http200(value: [Pet]?, raw: ClientResponse)
        case http400(value: Void?, raw: ClientResponse)
        case http0(value: [Pet]?, raw: ClientResponse)
    }

    /**
     Finds Pets by status

     GET /pet/findByStatus

     Multiple status values can be provided with comma separated strings

     - OAuth:
       - type: oauth2
       - name: petstore_auth
     - parameter status: (query) Status values that need to be considered for filter 
     - returns: `EventLoopFuture` of `FindPetsByStatus` 
     */
    open class func findPetsByStatus(status: [Status_findPetsByStatus], headers: HTTPHeaders = PetstoreClient.customHeaders, beforeSend: (inout ClientRequest) throws -> () = { _ in }) -> EventLoopFuture<FindPetsByStatus> {
        let path = "/pet/findByStatus"
        let URLString = PetstoreClient.basePath + path

        guard let apiClient = Configuration.apiClient else {
            fatalError("Configuration.apiClient is not set.")
        }

        return apiClient.send(.GET, headers: headers, to: URI(string: URLString)) { request in
            try Configuration.apiWrapper(&request)
            
            struct QueryParams: Content {
                var status: [Status_findPetsByStatus]
            }
            try request.query.encode(QueryParams(status: status))
            
            try beforeSend(&request)
        }.flatMapThrowing { response -> FindPetsByStatus in
            switch response.status.code {
            case 200:
                return .http200(value: try? response.content.decode([Pet].self, using: Configuration.contentConfiguration.requireDecoder(for: [Pet].defaultContentType)), raw: response)
            case 400:
                return .http400(value: (), raw: response)
            default:
                return .http0(value: try? response.content.decode([Pet].self, using: Configuration.contentConfiguration.requireDecoder(for: [Pet].defaultContentType)), raw: response)
            }
        }
    }



    public enum FindPetsByTags {
        case http200(value: [Pet]?, raw: ClientResponse)
        case http400(value: Void?, raw: ClientResponse)
        case http0(value: [Pet]?, raw: ClientResponse)
    }

    /**
     Finds Pets by tags

     GET /pet/findByTags

     Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.

     - OAuth:
       - type: oauth2
       - name: petstore_auth
     - parameter tags: (query) Tags to filter by 
     - returns: `EventLoopFuture` of `FindPetsByTags` 
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open class func findPetsByTags(tags: [String], headers: HTTPHeaders = PetstoreClient.customHeaders, beforeSend: (inout ClientRequest) throws -> () = { _ in }) -> EventLoopFuture<FindPetsByTags> {
        let path = "/pet/findByTags"
        let URLString = PetstoreClient.basePath + path

        guard let apiClient = Configuration.apiClient else {
            fatalError("Configuration.apiClient is not set.")
        }

        return apiClient.send(.GET, headers: headers, to: URI(string: URLString)) { request in
            try Configuration.apiWrapper(&request)
            
            struct QueryParams: Content {
                var tags: [String]
            }
            try request.query.encode(QueryParams(tags: tags))
            
            try beforeSend(&request)
        }.flatMapThrowing { response -> FindPetsByTags in
            switch response.status.code {
            case 200:
                return .http200(value: try? response.content.decode([Pet].self, using: Configuration.contentConfiguration.requireDecoder(for: [Pet].defaultContentType)), raw: response)
            case 400:
                return .http400(value: (), raw: response)
            default:
                return .http0(value: try? response.content.decode([Pet].self, using: Configuration.contentConfiguration.requireDecoder(for: [Pet].defaultContentType)), raw: response)
            }
        }
    }



    public enum GetPetById {
        case http200(value: Pet?, raw: ClientResponse)
        case http400(value: Void?, raw: ClientResponse)
        case http404(value: Void?, raw: ClientResponse)
        case http0(value: Pet?, raw: ClientResponse)
    }

    /**
     Find pet by ID

     GET /pet/{petId}

     Returns a single pet

     - API Key:
       - type: apiKey api_key 
       - name: api_key
     - parameter petId: (path) ID of pet to return 
     - returns: `EventLoopFuture` of `GetPetById` 
     */
    open class func getPetById(petId: Int64, headers: HTTPHeaders = PetstoreClient.customHeaders, beforeSend: (inout ClientRequest) throws -> () = { _ in }) -> EventLoopFuture<GetPetById> {
        var path = "/pet/{petId}"
        let petIdPreEscape = String(describing: petId)
        let petIdPostEscape = petIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{petId}", with: petIdPostEscape, options: .literal, range: nil)
        let URLString = PetstoreClient.basePath + path

        guard let apiClient = Configuration.apiClient else {
            fatalError("Configuration.apiClient is not set.")
        }

        return apiClient.send(.GET, headers: headers, to: URI(string: URLString)) { request in
            try Configuration.apiWrapper(&request)
            
            
            
            try beforeSend(&request)
        }.flatMapThrowing { response -> GetPetById in
            switch response.status.code {
            case 200:
                return .http200(value: try? response.content.decode(Pet.self, using: Configuration.contentConfiguration.requireDecoder(for: Pet.defaultContentType)), raw: response)
            case 400:
                return .http400(value: (), raw: response)
            case 404:
                return .http404(value: (), raw: response)
            default:
                return .http0(value: try? response.content.decode(Pet.self, using: Configuration.contentConfiguration.requireDecoder(for: Pet.defaultContentType)), raw: response)
            }
        }
    }



    public enum UpdatePet {
        case http400(value: Void?, raw: ClientResponse)
        case http404(value: Void?, raw: ClientResponse)
        case http405(value: Void?, raw: ClientResponse)
        case http0(value: Void?, raw: ClientResponse)
    }

    /**
     Update an existing pet

     PUT /pet

     - OAuth:
       - type: oauth2
       - name: petstore_auth
     - parameter body: (body) Pet object that needs to be added to the store 
     - returns: `EventLoopFuture` of `UpdatePet` 
     */
    open class func updatePet(body: Pet, headers: HTTPHeaders = PetstoreClient.customHeaders, beforeSend: (inout ClientRequest) throws -> () = { _ in }) -> EventLoopFuture<UpdatePet> {
        let path = "/pet"
        let URLString = PetstoreClient.basePath + path

        guard let apiClient = Configuration.apiClient else {
            fatalError("Configuration.apiClient is not set.")
        }

        return apiClient.send(.PUT, headers: headers, to: URI(string: URLString)) { request in
            try Configuration.apiWrapper(&request)
            
            
            try request.content.encode(body, using: Configuration.contentConfiguration.requireEncoder(for: Pet.defaultContentType))
            
            try beforeSend(&request)
        }.flatMapThrowing { response -> UpdatePet in
            switch response.status.code {
            case 400:
                return .http400(value: (), raw: response)
            case 404:
                return .http404(value: (), raw: response)
            case 405:
                return .http405(value: (), raw: response)
            default:
                return .http0(value: (), raw: response)
            }
        }
    }



    public enum UpdatePetWithForm {
        case http405(value: Void?, raw: ClientResponse)
        case http0(value: Void?, raw: ClientResponse)
    }

    /**
     Updates a pet in the store with form data

     POST /pet/{petId}

     - OAuth:
       - type: oauth2
       - name: petstore_auth
     - parameter petId: (path) ID of pet that needs to be updated 
     - parameter name: (form) Updated name of the pet (optional)
     - parameter status: (form) Updated status of the pet (optional)
     - returns: `EventLoopFuture` of `UpdatePetWithForm` 
     */
    open class func updatePetWithForm(petId: Int64, name: String? = nil, status: String? = nil, headers: HTTPHeaders = PetstoreClient.customHeaders, beforeSend: (inout ClientRequest) throws -> () = { _ in }) -> EventLoopFuture<UpdatePetWithForm> {
        var path = "/pet/{petId}"
        let petIdPreEscape = String(describing: petId)
        let petIdPostEscape = petIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{petId}", with: petIdPostEscape, options: .literal, range: nil)
        let URLString = PetstoreClient.basePath + path

        guard let apiClient = Configuration.apiClient else {
            fatalError("Configuration.apiClient is not set.")
        }

        return apiClient.send(.POST, headers: headers, to: URI(string: URLString)) { request in
            try Configuration.apiWrapper(&request)
            
            
            struct FormParams: Content {
                static let defaultContentType = Vapor.HTTPMediaType.formData
                var name: String?
                var status: String?
            }
            try request.content.encode(FormParams(name: name, status: status), using: Configuration.contentConfiguration.requireEncoder(for: FormParams.defaultContentType))
            try beforeSend(&request)
        }.flatMapThrowing { response -> UpdatePetWithForm in
            switch response.status.code {
            case 405:
                return .http405(value: (), raw: response)
            default:
                return .http0(value: (), raw: response)
            }
        }
    }



    public enum UploadFile {
        case http200(value: ApiResponse?, raw: ClientResponse)
        case http0(value: ApiResponse?, raw: ClientResponse)
    }

    /**
     uploads an image

     POST /pet/{petId}/uploadImage

     - OAuth:
       - type: oauth2
       - name: petstore_auth
     - parameter petId: (path) ID of pet to update 
     - parameter additionalMetadata: (form) Additional data to pass to server (optional)
     - parameter file: (form) file to upload (optional)
     - returns: `EventLoopFuture` of `UploadFile` 
     */
    open class func uploadFile(petId: Int64, additionalMetadata: String? = nil, file: Data? = nil, headers: HTTPHeaders = PetstoreClient.customHeaders, beforeSend: (inout ClientRequest) throws -> () = { _ in }) -> EventLoopFuture<UploadFile> {
        var path = "/pet/{petId}/uploadImage"
        let petIdPreEscape = String(describing: petId)
        let petIdPostEscape = petIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{petId}", with: petIdPostEscape, options: .literal, range: nil)
        let URLString = PetstoreClient.basePath + path

        guard let apiClient = Configuration.apiClient else {
            fatalError("Configuration.apiClient is not set.")
        }

        return apiClient.send(.POST, headers: headers, to: URI(string: URLString)) { request in
            try Configuration.apiWrapper(&request)
            
            
            struct FormParams: Content {
                static let defaultContentType = Vapor.HTTPMediaType.formData
                var additionalMetadata: String?
                var file: Data?
            }
            try request.content.encode(FormParams(additionalMetadata: additionalMetadata, file: file), using: Configuration.contentConfiguration.requireEncoder(for: FormParams.defaultContentType))
            try beforeSend(&request)
        }.flatMapThrowing { response -> UploadFile in
            switch response.status.code {
            case 200:
                return .http200(value: try? response.content.decode(ApiResponse.self, using: Configuration.contentConfiguration.requireDecoder(for: ApiResponse.defaultContentType)), raw: response)
            default:
                return .http0(value: try? response.content.decode(ApiResponse.self, using: Configuration.contentConfiguration.requireDecoder(for: ApiResponse.defaultContentType)), raw: response)
            }
        }
    }



    public enum UploadFileWithRequiredFile {
        case http200(value: ApiResponse?, raw: ClientResponse)
        case http0(value: ApiResponse?, raw: ClientResponse)
    }

    /**
     uploads an image (required)

     POST /fake/{petId}/uploadImageWithRequiredFile

     - OAuth:
       - type: oauth2
       - name: petstore_auth
     - parameter petId: (path) ID of pet to update 
     - parameter requiredFile: (form) file to upload 
     - parameter additionalMetadata: (form) Additional data to pass to server (optional)
     - returns: `EventLoopFuture` of `UploadFileWithRequiredFile` 
     */
    open class func uploadFileWithRequiredFile(petId: Int64, requiredFile: Data, additionalMetadata: String? = nil, headers: HTTPHeaders = PetstoreClient.customHeaders, beforeSend: (inout ClientRequest) throws -> () = { _ in }) -> EventLoopFuture<UploadFileWithRequiredFile> {
        var path = "/fake/{petId}/uploadImageWithRequiredFile"
        let petIdPreEscape = String(describing: petId)
        let petIdPostEscape = petIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{petId}", with: petIdPostEscape, options: .literal, range: nil)
        let URLString = PetstoreClient.basePath + path

        guard let apiClient = Configuration.apiClient else {
            fatalError("Configuration.apiClient is not set.")
        }

        return apiClient.send(.POST, headers: headers, to: URI(string: URLString)) { request in
            try Configuration.apiWrapper(&request)
            
            
            struct FormParams: Content {
                static let defaultContentType = Vapor.HTTPMediaType.formData
                var additionalMetadata: String?
                var requiredFile: Data
            }
            try request.content.encode(FormParams(additionalMetadata: additionalMetadata, requiredFile: requiredFile), using: Configuration.contentConfiguration.requireEncoder(for: FormParams.defaultContentType))
            try beforeSend(&request)
        }.flatMapThrowing { response -> UploadFileWithRequiredFile in
            switch response.status.code {
            case 200:
                return .http200(value: try? response.content.decode(ApiResponse.self, using: Configuration.contentConfiguration.requireDecoder(for: ApiResponse.defaultContentType)), raw: response)
            default:
                return .http0(value: try? response.content.decode(ApiResponse.self, using: Configuration.contentConfiguration.requireDecoder(for: ApiResponse.defaultContentType)), raw: response)
            }
        }
    }


}
